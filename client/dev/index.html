<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Formgen Runtime Sandbox</title>

    <!-- Load Tailwind CSS -->
    <link rel="stylesheet" href="./styles.css" />

    <style>
      /* Minimal wrapper styling - does NOT override form styles */
      body {
        margin: 0;
        padding: 1.5rem;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        background: #f5f5f5;
      }

      .sandbox-header {
        max-width: 50rem;
        margin: 0 auto 2rem;
        text-align: center;
      }

      .sandbox-header h1 {
        margin: 0 0 0.5rem;
        font-size: 1.75rem;
        color: #111;
      }

      .sandbox-header p {
        margin: 0 0 1rem;
        font-size: 0.875rem;
        color: #666;
        line-height: 1.5;
      }

      .sandbox-controls {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        align-items: center;
        margin-top: 1rem;
      }

      .sandbox-controls label {
        font-size: 0.875rem;
        font-weight: 500;
        color: #374151;
      }

      .sandbox-controls select {
        padding: 0.375rem 0.75rem;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        background: white;
        cursor: pointer;
      }

      .sandbox-controls select:focus {
        outline: none;
        border-color: #2563eb;
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      .sandbox-container {
        max-width: 50rem;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <header class="sandbox-header">
      <h1>Formgen Runtime Sandbox</h1>
      <p>
        Production preview: This loads the exact CSS and runtime that ships with the Go package.
        Edit <code>src/</code> to see changes.
      </p>
      <div class="sandbox-controls">
        <label for="view-select">View:</label>
        <select id="view-select">
          <option value="vanilla">Vanilla (Go Rendered + Tailwind)</option>
          <option value="preact">Preact (Client Components)</option>
        </select>
      </div>
    </header>

    <div class="sandbox-container">
      <div id="app"></div>
    </div>

    <script type="module">
      import { initRelationships } from "../src/index.ts";

      // Set up view selector
      const viewSelect = document.getElementById('view-select');
      viewSelect.value = 'vanilla';

      // Handle view change
      viewSelect.addEventListener('change', (e) => {
        const newView = e.target.value;
        if (newView === 'preact') {
          window.location.href = '/preact/';
        }
      });

      const schema = await loadSchema();
      const form = buildForm(schema, "createArticle");
      const app = document.getElementById("app");
      app.innerHTML = "";
      app.appendChild(form);

      installMockApi();
      await initRelationships({ searchThrottleMs: 150, searchDebounceMs: 150 });

      function humaniseLabel(key) {
        return key
          .replace(/\[(.+?)\]/g, " $1")
          .replace(/[_\s]+/g, " ")
          .replace(/\b\w/g, (char) => char.toUpperCase())
          .trim();
      }

      function sanitizeId(value) {
        return value.replace(/[\[\]\s]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }

      async function loadSchema() {
        const response = await fetch("./schema.json", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load schema: ${response.status}`);
        }
        return response.json();
      }

      function buildForm(documentSchema, operationId) {
        const form = document.createElement("form");
        form.className = "grid gap-6 p-6 bg-white rounded-lg border border-gray-200";
        form.dataset.formgenAutoInit = "true";
        form.noValidate = true;

        const operation = findOperation(documentSchema, operationId);
        if (!operation) {
          form.appendChild(document.createTextNode(`Operation ${operationId} not found in schema.`));
          return form;
        }

        const articleSchema =
          operation?.requestBody?.content?.["application/json"]?.schema?.properties?.article;
        if (!articleSchema) {
          form.appendChild(document.createTextNode("Article schema missing in OpenAPI document."));
          return form;
        }

        const required = new Set(articleSchema.required ?? []);
        const properties = articleSchema.properties ?? {};

        Object.entries(properties).forEach(([key, spec]) => {
          const field = createField("article", key, spec, required.has(key), documentSchema);
          if (field) {
            form.appendChild(field);
          }
        });

        const actions = document.createElement("div");
        actions.className = "flex gap-2";
        const submit = document.createElement("button");
        submit.type = "submit";
        submit.className = "px-4 py-2 text-sm font-medium rounded-md bg-blue-600 text-white hover:bg-blue-700";
        submit.textContent = "Submit";
        actions.appendChild(submit);
        form.appendChild(actions);

        return form;
      }

      function findOperation(doc, operationId) {
        const paths = doc?.paths ?? {};
        for (const path of Object.values(paths)) {
          for (const method of Object.values(path ?? {})) {
            if (method?.operationId === operationId) {
              return method;
            }
          }
        }
        return undefined;
      }

      function resolveRef(doc, ref) {
        if (!ref || typeof ref !== "string" || !ref.startsWith("#/")) {
          return undefined;
        }
        const parts = ref.slice(2).split("/");
        return parts.reduce((acc, part) => (acc ? acc[part] : undefined), doc);
      }

      function dereferenceSchema(doc, spec) {
        if (!spec) {
          return spec;
        }
        if (spec.$ref) {
          return dereferenceSchema(doc, resolveRef(doc, spec.$ref));
        }
        if (Array.isArray(spec.allOf) && spec.allOf.length > 0) {
          return spec.allOf.reduce(
            (acc, entry) => ({
              ...acc,
              ...dereferenceSchema(doc, entry),
            }),
            { ...spec, allOf: undefined }
          );
        }
        return spec;
      }

      function createField(scope, key, originalSpec, required, doc) {
        const spec = dereferenceSchema(doc, originalSpec) ?? originalSpec ?? {};

        // Skip relationship objects that have a sourceField pointing to another field
        // (e.g., skip "author" object if "author_id" field exists with x-endpoint)
        if (spec.type === "object" && spec["x-relationships"]?.sourceField) {
          return null;
        }

        // Check for relationships FIRST - they take precedence over object type
        if (spec.type === "array" && spec.items && spec["x-endpoint"]) {
          return buildSelectField(scope, key, spec, required, { multiple: true });
        }

        if (spec["x-endpoint"]) {
          return buildSelectField(scope, key, spec, required);
        }

        // Only create fieldset if it's an object WITHOUT x-endpoint
        if (spec.type === "object" && spec.properties) {
          const fieldset = document.createElement("fieldset");
          fieldset.className = "fg-fieldset";
          const legend = document.createElement("legend");
          legend.textContent = humaniseLabel(key);
          fieldset.appendChild(legend);
          applyRelationshipAttributes(fieldset, spec["x-relationships"]);

          const nestedRequired = new Set(spec.required ?? []);
          Object.entries(spec.properties).forEach(([nestedKey, nestedSpec]) => {
            const child = createField(
              `${scope}[${key}]`,
              nestedKey,
              nestedSpec,
              nestedRequired.has(nestedKey),
              doc
            );
            if (child) {
              fieldset.appendChild(child);
            }
          });
          return fieldset;
        }

        if (spec.type === "string" || spec.type === "number" || spec.type === "integer") {
          return buildInputField(scope, key, spec, required);
        }

        // Skip unsupported field types for the sandbox
        return null;
      }

      function buildSelectField(scope, key, spec, required, options = {}) {
        const wrapper = document.createElement("div");
        wrapper.className = "grid gap-2";

        const controlId = `fg-${sanitizeId(`${scope}-${key}`)}`;
        const label = document.createElement("label");
        label.htmlFor = controlId;
        label.className = "text-sm font-medium text-gray-900";
        label.textContent = humaniseLabel(key);
        wrapper.appendChild(label);

        const select = document.createElement("select");
        select.id = controlId;
        select.className = "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500";
        select.name = options.multiple ? `${scope}[${key}][]` : `${scope}[${key}]`;
        select.required = Boolean(required);

        if (options.multiple) {
          select.multiple = true;
          select.setAttribute("data-endpoint-renderer", "chips");
          select.setAttribute("data-endpoint-search-placeholder", `Search ${humaniseLabel(key)}`);
        }

        applyEndpointAttributes(select, spec["x-endpoint"]);
        applyRelationshipAttributes(select, spec["x-relationships"]);

        const labelText = humaniseLabel(key);
        const placeholderText = spec.uiHints?.placeholder ?? `Select ${labelText}`;

        if (!select.hasAttribute("data-endpoint-field-label")) {
          select.setAttribute("data-endpoint-field-label", labelText);
        }
        if (!select.hasAttribute("data-endpoint-placeholder")) {
          select.setAttribute("data-endpoint-placeholder", placeholderText);
        }
        if (
          !options.multiple &&
          !select.hasAttribute("data-endpoint-renderer") &&
          spec["x-relationships"]?.cardinality !== "many" &&
          spec["x-endpoint"]
        ) {
          select.setAttribute("data-endpoint-renderer", "typeahead");
        }
        if (
          select.getAttribute("data-endpoint-mode") === "search" &&
          !select.hasAttribute("data-endpoint-search-placeholder")
        ) {
          select.setAttribute("data-endpoint-search-placeholder", `Search ${labelText}`);
        }
        const placeholderOption = document.createElement("option");
        placeholderOption.value = "";
        placeholderOption.textContent = placeholderText;
        select.appendChild(placeholderOption);

        wrapper.appendChild(select);

        if (spec.description) {
          const help = document.createElement("small");
          help.className = "text-sm text-gray-500";
          help.textContent = spec.description;
          wrapper.appendChild(help);
        }

        return wrapper;
      }

      function buildInputField(scope, key, spec, required) {
        const wrapper = document.createElement("div");
        wrapper.className = "grid gap-2";

        const controlId = `fg-${sanitizeId(`${scope}-${key}`)}`;
        const label = document.createElement("label");
        label.htmlFor = controlId;
        label.className = "text-sm font-medium text-gray-900";
        label.textContent = humaniseLabel(key);
        wrapper.appendChild(label);

        const input = document.createElement("input");
        input.id = controlId;
        input.className = "w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500";
        input.name = `${scope}[${key}]`;
        input.required = Boolean(required);
        input.placeholder = spec.placeholder ?? `Enter ${humaniseLabel(key)}`;

        if (spec.format === "date-time") {
          input.type = "datetime-local";
        } else if (spec.type === "number" || spec.type === "integer") {
          input.type = "number";
        } else {
          input.type = "text";
        }

        wrapper.appendChild(input);

        if (spec.description) {
          const help = document.createElement("small");
          help.className = "text-sm text-gray-500";
          help.textContent = spec.description;
          wrapper.appendChild(help);
        }

        return wrapper;
      }

      function applyEndpointAttributes(element, endpoint) {
        if (!endpoint) {
          return;
        }

        const set = (name, value) => {
          if (value !== undefined && value !== null && value !== "") {
            element.setAttribute(name, String(value));
          }
        };

        set("data-endpoint-url", endpoint.url);
        set("data-endpoint-method", (endpoint.method ?? "GET").toUpperCase());
        set("data-endpoint-label-field", endpoint.labelField);
        set("data-endpoint-value-field", endpoint.valueField);
        set("data-endpoint-results-path", endpoint.resultsPath);
        set("data-endpoint-renderer", endpoint.renderer);
        set("data-endpoint-mode", endpoint.mode);
        set("data-endpoint-search-param", endpoint.searchParam);
        set("data-endpoint-submit-as", endpoint.submitAs);

        if (endpoint.params) {
          Object.entries(endpoint.params).forEach(([key, value]) => {
            set(`data-endpoint-params-${toDataKey(key)}`, value);
          });
        }

        if (endpoint.dynamicParams) {
          Object.entries(endpoint.dynamicParams).forEach(([key, value]) => {
            set(`data-endpoint-dynamic-params-${toDataKey(key)}`, value);
          });
        }
      }

      function applyRelationshipAttributes(element, relationship) {
        if (!relationship) {
          return;
        }
        const set = (name, value) => {
          if (value !== undefined && value !== null && value !== "") {
            element.setAttribute(name, String(value));
          }
        };
        set("data-relationship-type", relationship.type);
        set("data-relationship-target", relationship.target);
        set("data-relationship-foreign-key", relationship.foreignKey);
        set("data-relationship-cardinality", relationship.cardinality);
        set("data-relationship-inverse", relationship.inverse);
        set("data-relationship-source-field", relationship.sourceField);
      }

      function toDataKey(value) {
        return String(value).replace(/[^a-zA-Z0-9]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }

      function installMockApi() {
        const realFetch = window.fetch.bind(window);

        const response = (options) =>
          new Response(JSON.stringify(options), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });

        const authors = [
          { value: "1", label: "Zoe Alvarez" },
          { value: "2", label: "Mason Fletcher" },
          { value: "3", label: "Priya Shah" },
          { value: "4", label: "Anika Patel" },
        ];

        const categories = [
          { value: "news", label: "News" },
          { value: "product", label: "Product" },
          { value: "culture", label: "Culture" },
          { value: "ops", label: "Operations" },
        ];

        const managers = [
          { value: "lead-1", label: "James Okafor" },
          { value: "lead-2", label: "Helena Park" },
          { value: "lead-3", label: "Sara Lindholm" },
        ];

        const tags = [
          { value: "design", label: "Product Design" },
          { value: "growth", label: "Growth" },
          { value: "ml", label: "Machine Learning" },
          { value: "ops", label: "Operations" },
          { value: "security", label: "Security" },
          { value: "ai", label: "AI Strategy" },
          { value: "devrel", label: "DevRel" },
        ];

        window.fetch = async (input, init) => {
          const url = new URL(typeof input === "string" ? input : input.url, window.location.origin);

          switch (url.pathname) {
            case "/api/authors":
              return response(authors);
            case "/api/categories":
              return response(categories);
            case "/api/managers":
              return response(managers);
            case "/api/tags": {
              const query = (url.searchParams.get("q") || "").toLowerCase();
              const filtered =
                query.length === 0
                  ? tags
                  : tags.filter(
                      (option) =>
                        option.label.toLowerCase().includes(query) ||
                        option.value.toLowerCase().includes(query)
                    );
              return response(filtered);
            }
            default:
              return realFetch(input, init);
          }
        };
      }
    </script>
  </body>
</html>
