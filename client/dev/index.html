<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Formgen Runtime Sandbox</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
      }

      body {
        margin: 0;
        min-height: 100vh;
      }

      .playground {
        margin: 0 auto;
        padding: 2.5rem 1.5rem 4rem;
        max-width: 70rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .playground h1 {
        margin: 0;
        font-size: clamp(2rem, 3vw, 2.5rem);
        font-weight: 700;
      }

      .playground p {
        margin: 0;
        max-width: 45rem;
        line-height: 1.6;
        color: #cbd5f5;
      }

      .sandbox-card {
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 1.25rem;
        padding: 2rem;
        backdrop-filter: blur(12px);
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.35);
      }

      .fg-form {
        display: grid;
        gap: 1.75rem;
      }

      .fg-field label {
        font-weight: 600;
        color: #f8fafc;
        display: block;
        margin-bottom: 0.5rem;
      }

      .fg-field__help {
        display: block;
        margin-top: 0.35rem;
        color: #94a3b8;
        font-size: 0.9rem;
      }

      .sandbox-note {
        font-size: 0.9rem;
        color: #94a3b8;
      }

      /* Extracted chips renderer styles from pkg/renderers/vanilla/assets/formgen-vanilla.css */
      .fg-chip-select__native {
        display: none;
      }

      .fg-chip-select {
        display: none;
        width: 100%;
        position: relative;
        border: 1px solid var(--fg-input-border, rgba(148, 163, 184, 0.35));
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.35);
        padding: 0.4rem 0.6rem;
        align-items: center;
        transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.45);
      }

      .fg-chip-select--ready {
        display: flex;
      }

      .fg-chip-select--open {
        border-color: rgba(148, 163, 184, 0.65);
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12);
        background: rgba(15, 23, 42, 0.85);
      }

      .fg-chip-select__inner {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex: 1 1 auto;
        min-height: 2.25rem;
      }

      .fg-chip-select__chips {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        flex: 1 1 auto;
      }

      .fg-chip-select__chips-content {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        align-items: center;
      }

      .fg-chip-select__search {
        flex: 1 1 8rem;
        min-width: 6rem;
        display: flex;
      }

      .fg-chip-select__search-input {
        flex: 1 1 auto;
        border: none;
        background: transparent;
        padding: 0.2rem 0.35rem;
        font: inherit;
        color: var(--fg-input-text, #f8fafc);
      }

      .fg-chip-select__search-input:focus {
        outline: none;
      }

      .fg-chip-select__search-input::placeholder {
        color: #9ca3af;
      }

      .fg-chip-select__search-highlight {
        background: #fde68a;
        color: inherit;
        padding: 0;
      }

      .fg-chip-select__placeholder {
        color: #cbd5f5;
        font-size: 0.95rem;
      }

      .fg-chip-select__chip {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        border-radius: 999px;
        border: 1px solid rgba(96, 165, 250, 0.6);
        background: rgba(59, 130, 246, 0.18);
        color: #dbeafe;
        padding: 0.3rem 0.75rem;
        font-weight: 500;
        line-height: 1;
        max-width: 100%;
      }

      .fg-chip-select__chip-label {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .fg-chip-select__chip-remove {
        background: transparent;
        border: none;
        color: #bfdbfe;
        cursor: pointer;
        font-size: 0.95rem;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        transition: color 0.15s ease;
      }

      .fg-chip-select__chip-remove:hover {
        color: #dbeafe;
      }

      .fg-chip-select__actions {
        display: flex;
        gap: 0.35rem;
      }

      .fg-chip-select__action {
        width: 1.75rem;
        height: 1.75rem;
        border-radius: 999px;
        border: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: rgba(59, 130, 246, 0.2);
        color: #bfdbfe;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease;
      }

      .fg-chip-select__action:hover:not(:disabled) {
        background: rgba(59, 130, 246, 0.35);
        color: #f1f5f9;
      }

      .fg-chip-select__action:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }

      .fg-chip-select__menu {
        position: absolute;
        z-index: 10;
        top: calc(100% + 0.5rem);
        left: 0;
        right: 0;
        border-radius: 1rem;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.2);
        padding: 0.75rem;
        display: grid;
        gap: 0.35rem;
        max-height: 18rem;
        overflow-y: auto;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.4);
      }

      .fg-chip-select__menu-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        border-radius: 0.75rem;
        background: transparent;
        padding: 0.65rem 0.85rem;
        border: none;
        color: #e2e8f0;
        cursor: pointer;
        text-align: left;
        transition: background 0.15s ease, transform 0.1s ease;
      }

      .fg-chip-select__menu-item:hover,
      .fg-chip-select__menu-item:focus-visible {
        background: rgba(59, 130, 246, 0.22);
        outline: none;
        transform: translateY(-1px);
      }

      .fg-chip-select__menu-empty {
        padding: 0.75rem;
        text-align: center;
        color: #94a3b8;
        font-style: italic;
      }

      .fg-chip-select [hidden] {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <main class="playground">
      <header>
        <h1>Formgen Runtime Sandbox</h1>
        <p>
          This playground loads the full OpenAPI schema from <code>client/data/schema.json</code>,
          synthesises the relationship-aware form markup, and boots the runtime against mocked HTTP
          endpoints. Tweak the TypeScript sources under <code>client/src</code> with
          <code>npm run watch</code> running and refresh to inspect the behaviour in a real UI.
        </p>
      </header>

      <section class="sandbox-card">
        <div id="app">
          <p class="sandbox-note">Loading schema &hellip;</p>
        </div>
      </section>
    </main>

    <script type="module">
      import { initRelationships } from "../dist/esm/index.js";

      const schema = await loadSchema();
      const form = buildForm(schema, "createArticle");
      const app = document.getElementById("app");
      app.innerHTML = "";
      app.appendChild(form);

      installMockApi();
      await initRelationships({ searchThrottleMs: 150, searchDebounceMs: 150 });

      function humaniseLabel(key) {
        return key
          .replace(/\[(.+?)\]/g, " $1")
          .replace(/[_\s]+/g, " ")
          .replace(/\b\w/g, (char) => char.toUpperCase())
          .trim();
      }

      function sanitizeId(value) {
        return value.replace(/[\[\]\s]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }

      async function loadSchema() {
        const response = await fetch("../data/schema.json", { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load schema: ${response.status}`);
        }
        return response.json();
      }

      function buildForm(documentSchema, operationId) {
        const form = document.createElement("form");
        form.className = "fg-form";
        form.dataset.formgenAutoInit = "true";
        form.noValidate = true;

        const operation = findOperation(documentSchema, operationId);
        if (!operation) {
          form.appendChild(document.createTextNode(`Operation ${operationId} not found in schema.`));
          return form;
        }

        const articleSchema =
          operation?.requestBody?.content?.["application/json"]?.schema?.properties?.article;
        if (!articleSchema) {
          form.appendChild(document.createTextNode("Article schema missing in OpenAPI document."));
          return form;
        }

        const required = new Set(articleSchema.required ?? []);
        const properties = articleSchema.properties ?? {};

        Object.entries(properties).forEach(([key, spec]) => {
          const field = createField("article", key, spec, required.has(key), documentSchema);
          if (field) {
            form.appendChild(field);
          }
        });

        const actions = document.createElement("div");
        actions.className = "fg-actions";
        const submit = document.createElement("button");
        submit.type = "submit";
        submit.textContent = "Submit";
        actions.appendChild(submit);
        form.appendChild(actions);

        return form;
      }

      function findOperation(doc, operationId) {
        const paths = doc?.paths ?? {};
        for (const path of Object.values(paths)) {
          for (const method of Object.values(path ?? {})) {
            if (method?.operationId === operationId) {
              return method;
            }
          }
        }
        return undefined;
      }

      function resolveRef(doc, ref) {
        if (!ref || typeof ref !== "string" || !ref.startsWith("#/")) {
          return undefined;
        }
        const parts = ref.slice(2).split("/");
        return parts.reduce((acc, part) => (acc ? acc[part] : undefined), doc);
      }

      function dereferenceSchema(doc, spec) {
        if (!spec) {
          return spec;
        }
        if (spec.$ref) {
          return dereferenceSchema(doc, resolveRef(doc, spec.$ref));
        }
        if (Array.isArray(spec.allOf) && spec.allOf.length > 0) {
          return spec.allOf.reduce(
            (acc, entry) => ({
              ...acc,
              ...dereferenceSchema(doc, entry),
            }),
            { ...spec, allOf: undefined }
          );
        }
        return spec;
      }

      function createField(scope, key, originalSpec, required, doc) {
        const spec = dereferenceSchema(doc, originalSpec) ?? originalSpec ?? {};

        if (spec.type === "object" && spec.properties) {
          const fieldset = document.createElement("fieldset");
          fieldset.className = "fg-fieldset";
          const legend = document.createElement("legend");
          legend.textContent = humaniseLabel(key);
          fieldset.appendChild(legend);
          applyRelationshipAttributes(fieldset, spec["x-relationships"]);

          const nestedRequired = new Set(spec.required ?? []);
          Object.entries(spec.properties).forEach(([nestedKey, nestedSpec]) => {
            const child = createField(
              `${scope}[${key}]`,
              nestedKey,
              nestedSpec,
              nestedRequired.has(nestedKey),
              doc
            );
            if (child) {
              fieldset.appendChild(child);
            }
          });
          return fieldset;
        }

        if (spec.type === "array" && spec.items && spec["x-endpoint"]) {
          return buildSelectField(scope, key, spec, required, { multiple: true });
        }

        if (spec["x-endpoint"]) {
          return buildSelectField(scope, key, spec, required);
        }

        if (spec.type === "string" || spec.type === "number" || spec.type === "integer") {
          return buildInputField(scope, key, spec, required);
        }

        // Skip unsupported field types for the sandbox
        return null;
      }

      function buildSelectField(scope, key, spec, required, options = {}) {
        const wrapper = document.createElement("div");
        wrapper.className = `fg-field fg-type-select`;

        const controlId = `fg-${sanitizeId(`${scope}-${key}`)}`;
        const label = document.createElement("label");
        label.htmlFor = controlId;
        label.textContent = humaniseLabel(key);
        wrapper.appendChild(label);

        const select = document.createElement("select");
        select.id = controlId;
        select.name = options.multiple ? `${scope}[${key}][]` : `${scope}[${key}]`;
        select.required = Boolean(required);

        if (options.multiple) {
          select.multiple = true;
          select.setAttribute("data-endpoint-renderer", "chips");
          select.setAttribute("data-endpoint-search-placeholder", `Search ${humaniseLabel(key)}`);
        }

        applyEndpointAttributes(select, spec["x-endpoint"]);
        applyRelationshipAttributes(select, spec["x-relationships"]);

        const placeholderText = spec.uiHints?.placeholder ?? `Select ${humaniseLabel(key)}`;
        const placeholderOption = document.createElement("option");
        placeholderOption.value = "";
        placeholderOption.textContent = placeholderText;
        select.appendChild(placeholderOption);

        wrapper.appendChild(select);

        if (spec.description) {
          const help = document.createElement("small");
          help.className = "fg-field__help";
          help.textContent = spec.description;
          wrapper.appendChild(help);
        }

        return wrapper;
      }

      function buildInputField(scope, key, spec, required) {
        const wrapper = document.createElement("div");
        wrapper.className = `fg-field fg-type-${spec.type ?? "string"}`;

        const controlId = `fg-${sanitizeId(`${scope}-${key}`)}`;
        const label = document.createElement("label");
        label.htmlFor = controlId;
        label.textContent = humaniseLabel(key);
        wrapper.appendChild(label);

        const input = document.createElement("input");
        input.id = controlId;
        input.name = `${scope}[${key}]`;
        input.required = Boolean(required);
        input.placeholder = spec.placeholder ?? `Enter ${humaniseLabel(key)}`;

        if (spec.format === "date-time") {
          input.type = "datetime-local";
        } else if (spec.type === "number" || spec.type === "integer") {
          input.type = "number";
        } else {
          input.type = "text";
        }

        wrapper.appendChild(input);

        if (spec.description) {
          const help = document.createElement("small");
          help.className = "fg-field__help";
          help.textContent = spec.description;
          wrapper.appendChild(help);
        }

        return wrapper;
      }

      function applyEndpointAttributes(element, endpoint) {
        if (!endpoint) {
          return;
        }

        const set = (name, value) => {
          if (value !== undefined && value !== null && value !== "") {
            element.setAttribute(name, String(value));
          }
        };

        set("data-endpoint-url", endpoint.url);
        set("data-endpoint-method", (endpoint.method ?? "GET").toUpperCase());
        set("data-endpoint-label-field", endpoint.labelField);
        set("data-endpoint-value-field", endpoint.valueField);
        set("data-endpoint-results-path", endpoint.resultsPath);
        set("data-endpoint-renderer", endpoint.renderer);
        set("data-endpoint-mode", endpoint.mode);
        set("data-endpoint-search-param", endpoint.searchParam);
        set("data-endpoint-submit-as", endpoint.submitAs);

        if (endpoint.params) {
          Object.entries(endpoint.params).forEach(([key, value]) => {
            set(`data-endpoint-params-${toDataKey(key)}`, value);
          });
        }

        if (endpoint.dynamicParams) {
          Object.entries(endpoint.dynamicParams).forEach(([key, value]) => {
            set(`data-endpoint-dynamic-params-${toDataKey(key)}`, value);
          });
        }
      }

      function applyRelationshipAttributes(element, relationship) {
        if (!relationship) {
          return;
        }
        const set = (name, value) => {
          if (value !== undefined && value !== null && value !== "") {
            element.setAttribute(name, String(value));
          }
        };
        set("data-relationship-type", relationship.type);
        set("data-relationship-target", relationship.target);
        set("data-relationship-foreign-key", relationship.foreignKey);
        set("data-relationship-cardinality", relationship.cardinality);
        set("data-relationship-inverse", relationship.inverse);
        set("data-relationship-source-field", relationship.sourceField);
      }

      function toDataKey(value) {
        return String(value).replace(/[^a-zA-Z0-9]+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }

      function installMockApi() {
        const realFetch = window.fetch.bind(window);

        const response = (options) =>
          new Response(JSON.stringify(options), {
            status: 200,
            headers: { "Content-Type": "application/json" },
          });

        const authors = [
          { value: "1", label: "Zoe Alvarez" },
          { value: "2", label: "Mason Fletcher" },
          { value: "3", label: "Priya Shah" },
          { value: "4", label: "Anika Patel" },
        ];

        const categories = [
          { value: "news", label: "News" },
          { value: "product", label: "Product" },
          { value: "culture", label: "Culture" },
          { value: "ops", label: "Operations" },
        ];

        const managers = [
          { value: "lead-1", label: "James Okafor" },
          { value: "lead-2", label: "Helena Park" },
          { value: "lead-3", label: "Sara Lindholm" },
        ];

        const tags = [
          { value: "design", label: "Product Design" },
          { value: "growth", label: "Growth" },
          { value: "ml", label: "Machine Learning" },
          { value: "ops", label: "Operations" },
          { value: "security", label: "Security" },
          { value: "ai", label: "AI Strategy" },
          { value: "devrel", label: "DevRel" },
        ];

        window.fetch = async (input, init) => {
          const url = new URL(typeof input === "string" ? input : input.url, window.location.origin);

          switch (url.pathname) {
            case "/api/authors":
              return response(authors);
            case "/api/categories":
              return response(categories);
            case "/api/managers":
              return response(managers);
            case "/api/tags": {
              const query = (url.searchParams.get("q") || "").toLowerCase();
              const filtered =
                query.length === 0
                  ? tags
                  : tags.filter(
                      (option) =>
                        option.label.toLowerCase().includes(query) ||
                        option.value.toLowerCase().includes(query)
                    );
              return response(filtered);
            }
            default:
              return realFetch(input, init);
          }
        };
      }
    </script>
  </body>
</html>
