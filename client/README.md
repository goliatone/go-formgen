# formgen Runtime Client

JavaScript/TypeScript runtime for resolving relationship fields in formgen-generated forms.

## Overview

This package provides browser-side relationship resolution for forms generated by the formgen Go library. Instead of server-side data fetching, the runtime reads `data-*` attributes from HTML and fetches relationship options from your REST API endpoints when forms load.

By default the resolver appends `?format=options` to relationship endpoints and expects an array of `{value,label}` objects. Legacy envelopes (such as `{"data":[...]}`) remain supported via the `resultsPath` metadata or a `transformOptions` hook when you need to adapt older payloads.

## Relationship Event Contract

The runtime uses DOM `CustomEvent`s to keep the relationship system decoupled and composable.

**Resolver lifecycle events (emitted by `client/src/registry.ts`)**
- `formgen:relationship:loading`
- `formgen:relationship:success`
- `formgen:relationship:error`
- `formgen:relationship:validation`

**Internal/UI update event (emitted by renderers + bridges)**
- `formgen:relationship:update` (see `client/src/relationship-events.ts`)

`formgen:relationship:update` includes a typed `detail` payload describing what changed:
- `kind: "options"` when resolver output re-syncs the `<select>` options
- `kind: "selection"` when the selected value(s) change
- `kind: "search"` when a search query changes (search-mode fields)

Design rules used throughout the codebase:
- Native `change` is reserved for external integration and form semantics.
- Internal wiring (renderers, mirror syncing) listens to `formgen:relationship:update` instead of `change`.
- Option syncing (`syncSelectOptions`) is intentionally side-effect free; renderers emit `kind:"options"` updates explicitly after syncing.

## Directory Structure

```
client/
├── src/                  # TypeScript source
│   ├── index.ts         # Main entry point, auto-init
│   ├── resolver.ts      # Core fetch/transform/render logic
│   ├── registry.ts      # Element registration and lifecycle
│   ├── config.ts        # Global configuration types
│   ├── dom.ts           # DOM utilities and dataset parsing
│   ├── auth.ts          # Auth header resolution
│   ├── state.ts         # State management helpers
│   ├── errors.ts        # Custom error types
│   ├── timers.ts        # Throttle/debounce for search
│   ├── relationship-events.ts  # Relationship update event contract
│   └── frameworks/
│       └── preact.ts    # Preact hooks integration
├── dist/                # Build output
│   ├── browser/         # IIFE bundles for <script> tags
│   ├── esm/             # ESM for bundlers
│   └── types/           # TypeScript declarations
├── scripts/
│   └── build.ts         # esbuild configuration
├── package.json
├── tsconfig.json
└── tsconfig.build.json
```

## Development Workflow

### Quick Start: Live Development (Recommended)

**No Go dependencies needed!** Develop features entirely in the browser:

```bash
npm run dev           # vanilla sandbox (default)
npm run dev:vanilla   # explicitly open the vanilla sandbox
npm run dev:preact    # open the Preact sandbox
npm run dev:theme     # watch Tailwind theme recompiles
```

This starts a Vite dev server at http://localhost:5173 with:
- ✅ Hot reload on file changes
- ✅ TypeScript source imports (no build step)
- ✅ Mock API responses
- ✅ Browser DevTools debugging
- ✅ Instant feedback loop

The sandbox (`dev/index.html`) demonstrates all features. See [dev/README.md](dev/README.md) for details.

### Regenerating the sandbox HTML form

The file `client/dev/data/article-form.html` is generated from the canonical OpenAPI + UI schema so front-end contributors can iterate without running the Go server. Whenever you change `client/data/schema.json` or `client/dev/ui-schema.json`, regenerate the sandbox HTML:

```bash
./taskfile client:generate:article-form
```

This task runs `go run ./scripts/generate-article-form`, which uses `client/data/schema.json` and the embedded UI schema to produce fresh markup. Commit the updated HTML so other developers see the same form in the sandbox.

### TUI renderer quick notes

- The Go side exposes a TUI renderer (`renderer: "tui"`) for interactive terminal sessions. It runs offline by default; relationship fetches only occur when you supply an HTTP client (omit `--tui-no-fetch` in `cmd/formgen-cli` or pass `tui.WithHTTPClient`).
- Output formats: JSON (default), form-url-encoded (`--tui-format form`), and PrettyText for inspection.
- CLI flags: `--renderer tui --tui-format json|form|pretty --tui-no-fetch`.
- Regenerate goldens after renderer changes with `./scripts/update_goldens.sh` (root) or `client/scripts/update_goldens.sh`.

### Building

```bash
# Install dependencies
npm install

# Build all outputs (types + bundles)
npm run build

# Watch mode for development
npm run watch

# Analyze bundle size
npm run build:stats

# Run tests
npm test

# Run tests in watch mode
npm test -- --watch
```

## Development Notes

- **Tailwind + Go templates**: The theme build now scans the Go source tree (`../pkg/**/*.{go,tmpl,html}` and `../examples/**/*.{go,html,tmpl}` inside `tailwind.config.js`) so utility classes declared inside Go strings are preserved. Whenever you introduce markup in Go, make sure the file path still matches those globs; if you move code elsewhere, update the config before rebuilding.
- **Dynamic classes**: Any class names assembled at runtime (for example via `fmt.Sprintf`) cannot be statically detected. Add them to the `safelist` array in `tailwind.config.js` so `npm run build:theme` keeps them in the output. We do not have an automated scanner for Go strings, so this manual safelist is the last resort for patterns Tailwind cannot see.

## Outputs

- **Browser bundle**: `dist/browser/formgen-relationships.min.js` (IIFE, 22KB minified)
- **ESM**: `dist/esm/index.js` (for Vite/webpack)
- **Preact**: `dist/browser/frameworks/preact.min.js`
- **Types**: `dist/types/index.d.ts`
- **Theme CSS**: `dist/themes/formgen.css` (Tailwind build)

### Theme Distribution

Run `npm run build:theme` to compile the Tailwind bundle into `dist/themes/formgen.css`. This file now contains both the utility classes used by the Go templates and the runtime widget styling (chips/typeahead). The Go vanilla renderer embeds its stylesheet from `pkg/renderers/vanilla/assets/formgen-vanilla.css`; replace that file with the generated CSS when you want the library to ship the latest theme. Teams that prefer to self-host can publish `dist/themes/formgen.css` via their CDN or static pipeline and load it alongside the runtime bundle instead of copying it into the Go assets. Custom themes come from editing `client/src/theme/index.css` or extending `tailwind.config.js`, then rerunning `npm run build:theme` (or `npm run dev:theme` for watch mode) to emit the overridden CSS.

## Usage

### Vanilla HTML

```html
<script src="/runtime/formgen-relationships.min.js" defer></script>
<script>
  window.addEventListener('DOMContentLoaded', function () {
    window.FormgenRelationships.initRelationships().catch(console.error);
  });
</script>

<form data-formgen-auto-init="true">
  <select
    name="publisher_id"
    data-relationship-type="belongsTo"
    data-endpoint-url="/api/publishers"
    data-endpoint-value-field="id"
    data-endpoint-label-field="name">
  </select>
</form>
```

### With Configuration

```javascript
import { initRelationships } from '@goliatone/formgen-runtime';

await initRelationships({
  buildHeaders: (ctx) => ({
    'Authorization': `Bearer ${getToken()}`,
  }),
  transformOptions: (data) => data.items || data,
  onError: (error, element) => {
    console.error('Failed to load options', error);
  },
  validateSelection: (_ctx, value) => {
    if (Array.isArray(value) && value.length > 5) {
      return {
        valid: false,
        messages: ["Select at most five tags."],
        errors: [{ code: "maxTags", message: "Select at most five tags." }],
      };
    }
    return { valid: true, messages: [], errors: [] };
  },
  onValidationError: (ctx, error) => {
    analytics.track("relationship-validation", {
      field: ctx.field.name,
      code: error.code,
    });
  },
});

// Manual mutations (behaviours, editors, etc.) can trigger validation explicitly.
const registry = await initRelationships();
await registry.validate(document.querySelector("#project_owner")!);
```

### Validation Hooks & Error Rendering

Vanilla templates emit canonical validation metadata so the runtime can remain stateless:

```html
<select
  name="article[category_id]"
  data-validation-label="Category"
  data-validation-required="true"
  data-validation-rules='[{"kind":"minLength","params":{"value":"3"}}]'
  data-validation-renderer="banner"
  …>
</select>
```

- `client/src/validation.ts` evaluates the built-in rules and exposes typed helpers (`ValidationResult`, `ValidationError`, `mergeValidationResults`). Every resolver stores the latest outcome under `resolver.state.validation`.
- `formgen:relationship:validation` fires after every validation pass (including `registry.validate(element)`), mirroring the existing loading/success/error lifecycle.
- The default error renderer writes inline copy, toggles `aria-invalid`, and sets `data-validation-state`/`data-validation-message`. `registerErrorRenderer(name, renderer)` lets consumers override the presentation (`data-validation-renderer="name"` on the field picks the renderer).

```ts
import { registerErrorRenderer } from "@goliatone/formgen-runtime";

registerErrorRenderer("banner", ({ element, message }) => {
  const host = element.closest("[data-relationship-type]") ?? element.parentElement;
  if (!host) return;
  let banner = host.querySelector<HTMLElement>("[data-demo-error-banner]");
  if (!banner) {
    banner = document.createElement("div");
    banner.className = "mt-2 flex items-center gap-2 rounded border border-red-200 bg-red-50 px-3 py-2 text-sm text-red-700";
    banner.setAttribute("data-demo-error-banner", "true");
    banner.setAttribute("role", "status");
    banner.setAttribute("aria-live", "polite");
    host.appendChild(banner);
  }
  banner.textContent = message ?? "";
});
```

### Hydrating Values After Partial Updates

The runtime now exposes `hydrateFormValues(root, payload)` so HTMX/LiveView style updates can keep existing DOM in sync without rerendering entire forms. The helper understands both dotted keys (`cta.headline`) and bracket syntax (`cta[headline]`), plus array semantics for has-many relationships.

```ts
import { hydrateFormValues } from "@goliatone/formgen-runtime";

// Apply server defaults after a partial fetch
hydrateFormValues(document, {
  values: {
    title: "Existing title",
    "cta.headline": "Ready to dig deeper?",
    tags: ["design", "ai"],
  },
  errors: {
    slug: ["Slug already taken"],
    tags: ["Select at least one tag"],
  },
});
```

- Passing `null` (or an empty array for multi-selects) clears the corresponding field.
- `errors` writes inline chrome plus `data-validation-state="invalid"` attributes, keeping assistive tech and custom renderers in sync.
- Relationship defaults are reused immediately: selects, chips, and typeahead controls render the preloaded selection before the resolver issues a fetch.
- Server-seeded errors remain visible until the user changes the field or you call `registry.validate(element)`—automatic resolver refreshes no longer wipe backend feedback.

### Preact

```typescript
import { useRelationshipOptions } from '@goliatone/formgen-runtime/frameworks/preact';

function PublisherSelect({ field }) {
  const { options, loading, error, validation } = useRelationshipOptions(field);

  return (
    <select name={field.name}>
      {loading ? <option>Loading...</option> : null}
      {options.map(opt => (
        <option key={opt.value} value={opt.value}>{opt.label}</option>
      ))}
      {validation?.valid === false ? (
        <option value="" disabled>{validation.messages[0]}</option>
      ) : null}
    </select>
  );
}
```

### Typeahead Renderer

Single-cardinality relationships automatically upgrade to the typeahead renderer when the schema exposes endpoint metadata. The runtime looks for the same `data-endpoint-*` attributes used by the chips renderer.

```html
<select
  name="article[author_id]"
  data-relationship-cardinality="one"
  data-endpoint-renderer="typeahead"
  data-endpoint-url="/api/authors"
  data-endpoint-label-field="full_name"
  data-endpoint-value-field="id"
  data-endpoint-search-param="q"
  data-endpoint-mode="search"
  data-endpoint-placeholder="Select Author"
  data-endpoint-search-placeholder="Search Author"
  data-endpoint-field-label="Author"
></select>
```

The vanilla bundle hides the `<select>` once the runtime initialises, replaces it with a combobox UI, and keeps the native control synchronised so HTML form submission and non-JS fallbacks continue to work. Keyboard navigation (`ArrowUp/Down`, `Enter`, `Escape`, `Tab`) and clear buttons are handled by the renderer; accessibility attributes (`role="combobox"`, `aria-expanded`, `aria-controls`) are applied automatically.

### Behaviors

Behaviour metadata attaches small progressive-enhancement helpers to rendered controls. Declare behaviours in your UI schema:

```json
"slug": {
  "component": "input",
  "componentOptions": {
    "behaviors": {
      "autoSlug": {"source": "title"}
    }
  }
}
```

The decorator emits `data-behavior="autoSlug"` plus a JSON payload in `data-behavior-config`. Load the runtime bundle and call `initBehaviors()` after the DOM is ready:

```html
<script src="/runtime/formgen-behaviors.min.js" defer></script>
<script>
  window.addEventListener('DOMContentLoaded', function () {
    window.FormgenBehaviors?.initBehaviors();
  });
</script>
```

ESM consumers can cherry-pick the registry:

```ts
import { initBehaviors, registerBehavior } from '@goliatone/formgen-runtime/behaviors';

registerBehavior('autoFocus', ({ element }) => element.focus());
const { dispose } = initBehaviors();
```

Use `registerBehavior` to add custom factories or override built-ins, and call `dispose()` during teardown/testing to unmount existing instances.

### Component Registry

Custom components can augment form fields without forking the vanilla renderer. Server templates emit `data-component` (and optional `data-component-config`) attributes when the UI schema assigns a component. Register a matching factory before calling `initRelationships`:

```ts
import {
  registerComponent,
  initRelationships,
} from '@goliatone/formgen-runtime';

registerComponent('status-pill', ({ element }) => {
  const pills = Array.from(element.querySelectorAll('[data-pill]'));
  const radios = Array.from(element.querySelectorAll<HTMLInputElement>('input[type="radio"]'));

  const activate = () => {
    const selected = element.querySelector<HTMLInputElement>('input[type="radio"]:checked');
    pills.forEach((pill) => {
      const input = pill.querySelector<HTMLInputElement>('input[type="radio"]');
      const active = input === selected;
      pill.classList.toggle('is-active', active);
    });
  };

  radios.forEach((input) => input.addEventListener('change', activate));
  activate();
});

await initRelationships();
```

Factories receive the host element, resolved configuration, and form root. During tests you can call `resetComponentRegistryForTests()` to clear registrations between suites.

#### Built-in file uploader

The runtime now ships a first-class file uploader component registered under `file_uploader`. Assign it in your UI schema:

```json
"avatar": {
  "label": "Profile Picture",
  "component": "file_uploader",
  "componentOptions": {
    "variant": "image",
    "uploadEndpoint": "/api/uploads/avatars",
    "maxSize": 5242880,
    "allowedTypes": ["image/jpeg", "image/png"],
    "autoUpload": true,
    "headers": {
      "Authorization": "meta:api-token"
    }
  }
}
```

The vanilla renderer emits the underlying `<input type="text">` and the runtime hides it, renders the selected uploader variant (button/image/dropzone), uploads files to the configured endpoint, and mirrors the returned URLs back into the form as hidden inputs (falling back to standard `field[]` entries when `multiple: true`). To defer uploads until submission, set `autoUpload: false`; the component will intercept the `<form>` submit event, upload sequentially, and re-submit once every file succeeds.

Authentication headers can reference meta or data attributes (e.g., `meta:api-token`, `data:auth-token`). Advanced consumers may override the default hidden-input serialization by supplying a `serialize(context)` hook when registering the component manually.

## Integration with formgen

The Go HTTP example serves this bundle automatically:

```go
// examples/http/main.go
if _, err := os.Stat("client/dist/browser"); err == nil {
    mux.Handle("/runtime/", http.StripPrefix("/runtime/",
        http.FileServer(http.Dir("client/dist/browser"))))
}
```

Start the example server:

```bash
go run examples/http/main.go -source examples/http/schema.json
# Visit http://localhost:8080/form?operation=author:create
```

## UI Schema Decorators

UI schema files let you control layout, grouping, and action bars without editing the OpenAPI document. Place JSON or YAML documents under a `ui/` directory (for example `ui/schema.json`) using the structure:

```json
{
  "operations": {
    "post-book:create": {
      "form": {
        "title": "Create Book",
        "subtitle": "Provide core details",
        "layout": {"gridColumns": 12, "gutter": "md"},
        "actions": [
          {"kind": "secondary", "label": "Cancel", "href": "/books"},
          {"kind": "primary", "label": "Create", "type": "submit"}
        ]
      },
      "sections": [
        {"id": "details", "title": "Details", "order": 0, "fieldset": true},
        {"id": "associations", "title": "Associations", "order": 1}
      ],
      "fields": {
        "title": {"section": "details", "order": 0, "grid": {"span": 12}},
        "author_id": {"section": "associations", "order": 0, "grid": {"span": 6}},
        "tags": {"section": "associations", "order": 1, "grid": {"span": 12}}
      }
    }
  }
}
```

The decorator merges form-level hints into `FormModel.Metadata`/`UIHints`, attaches `layout.section` metadata to each field, and stores actions for the renderer to consume. Load the schema by wiring an `fs.FS` into the orchestrator:

```go
uiFS := os.DirFS("examples/http/ui")
orch := formgen.NewOrchestrator(
    orchestrator.WithUISchemaFS(uiFS),
)
```

When no schema is supplied the decorator is skipped and the vanilla renderer falls back to the linear layout.

## Features

- ✅ Auto-init from `data-formgen-auto-init` forms
- ✅ Fetch options from REST endpoints
- ✅ Shared query parameters (`limit`, `order`, `select`, `include`) propagate from schema metadata to keep requests consistent
- ✅ Dependent field refresh (cascade dropdowns)
- ✅ Search mode with throttle/debounce
- ✅ Auth header resolution (meta tags, data attributes, callbacks)
- ✅ In-memory caching with TTL
- ✅ JSON submission encoding for has-many
- ✅ Error handling with retry/backoff
- ✅ Lifecycle events (loading, success, error)
- ✅ Custom renderer registration

## Documentation

See parent repository docs:
- [JS_TDD.md](../JS_TDD.md) - Technical design document
- [JS_TSK.md](../JS_TSK.md) - Implementation tasks
- [REL_TDD.md](../REL_TDD.md) - Relationship feature overview
- [go-form-gen.md](../go-form-gen.md) - Main formgen documentation

## License

Same as parent repository (formgen).
